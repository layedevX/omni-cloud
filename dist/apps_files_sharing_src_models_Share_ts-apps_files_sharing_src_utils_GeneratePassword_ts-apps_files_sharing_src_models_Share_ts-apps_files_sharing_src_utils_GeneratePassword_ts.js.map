{"version":3,"file":"apps_files_sharing_src_models_Share_ts-apps_files_sharing_src_utils_GeneratePassword_ts-apps_files_sharing_src_models_Share_ts-apps_files_sharing_src_utils_GeneratePassword_ts.js?v=fdd3d746f857f7a26f8d","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///nextcloud/apps/files_sharing/src/models/Share.ts","webpack:///nextcloud/apps/files_sharing/src/utils/GeneratePassword.ts"],"sourcesContent":["function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { isFileRequest } from \"../services/SharingService\";\nexport default class Share {\n  /**\n   * Create the share object\n   *\n   * @param {object} ocsData ocs request response\n   */\n  constructor(ocsData) {\n    _defineProperty(this, \"_share\", void 0);\n    if (ocsData.ocs && ocsData.ocs.data && ocsData.ocs.data[0]) {\n      ocsData = ocsData.ocs.data[0];\n    }\n    // string to int\n    if (typeof ocsData.id === 'string') {\n      ocsData.id = Number.parseInt(ocsData.id);\n    }\n    // convert int into boolean\n    ocsData.hide_download = !!ocsData.hide_download;\n    ocsData.mail_send = !!ocsData.mail_send;\n    if (ocsData.attributes && typeof ocsData.attributes === 'string') {\n      try {\n        ocsData.attributes = JSON.parse(ocsData.attributes);\n      } catch (e) {\n        console.warn('Could not parse share attributes returned by server', ocsData.attributes);\n      }\n    }\n    ocsData.attributes = ocsData.attributes ?? [];\n    // store state\n    this._share = ocsData;\n  }\n  /**\n   * Get the share state\n   * ! used for reactivity purpose\n   * Do not remove. It allow vuejs to\n   * inject its watchers into the #share\n   * state and make the whole class reactive\n   *\n   * @return {object} the share raw state\n   */\n  get state() {\n    return this._share;\n  }\n  /**\n   * get the share id\n   */\n  get id() {\n    return this._share.id;\n  }\n  /**\n   * Get the share type\n   */\n  get type() {\n    return this._share.share_type;\n  }\n  /**\n   * Get the share permissions\n   * See window.OC.PERMISSION_* variables\n   */\n  get permissions() {\n    return this._share.permissions;\n  }\n  /**\n   * Get the share attributes\n   */\n  get attributes() {\n    return this._share.attributes || [];\n  }\n  /**\n   * Set the share permissions\n   * See window.OC.PERMISSION_* variables\n   */\n  set permissions(permissions) {\n    this._share.permissions = permissions;\n  }\n  // SHARE OWNER --------------------------------------------------\n  /**\n   * Get the share owner uid\n   */\n  get owner() {\n    return this._share.uid_owner;\n  }\n  /**\n   * Get the share owner's display name\n   */\n  get ownerDisplayName() {\n    return this._share.displayname_owner;\n  }\n  // SHARED WITH --------------------------------------------------\n  /**\n   * Get the share with entity uid\n   */\n  get shareWith() {\n    return this._share.share_with;\n  }\n  /**\n   * Get the share with entity display name\n   * fallback to its uid if none\n   */\n  get shareWithDisplayName() {\n    return this._share.share_with_displayname || this._share.share_with;\n  }\n  /**\n   * Unique display name in case of multiple\n   * duplicates results with the same name.\n   */\n  get shareWithDisplayNameUnique() {\n    return this._share.share_with_displayname_unique || this._share.share_with;\n  }\n  /**\n   * Get the share with entity link\n   */\n  get shareWithLink() {\n    return this._share.share_with_link;\n  }\n  /**\n   * Get the share with avatar if any\n   */\n  get shareWithAvatar() {\n    return this._share.share_with_avatar;\n  }\n  // SHARED FILE OR FOLDER OWNER ----------------------------------\n  /**\n   * Get the shared item owner uid\n   */\n  get uidFileOwner() {\n    return this._share.uid_file_owner;\n  }\n  /**\n   * Get the shared item display name\n   * fallback to its uid if none\n   */\n  get displaynameFileOwner() {\n    return this._share.displayname_file_owner || this._share.uid_file_owner;\n  }\n  // TIME DATA ----------------------------------------------------\n  /**\n   * Get the share creation timestamp\n   */\n  get createdTime() {\n    return this._share.stime;\n  }\n  /**\n   * Get the expiration date\n   * @return {string} date with YYYY-MM-DD format\n   */\n  get expireDate() {\n    return this._share.expiration;\n  }\n  /**\n   * Set the expiration date\n   * @param {string} date the share expiration date with YYYY-MM-DD format\n   */\n  set expireDate(date) {\n    this._share.expiration = date;\n  }\n  // EXTRA DATA ---------------------------------------------------\n  /**\n   * Get the public share token\n   */\n  get token() {\n    return this._share.token;\n  }\n  /**\n   * Set the public share token\n   */\n  set token(token) {\n    this._share.token = token;\n  }\n  /**\n   * Get the share note if any\n   */\n  get note() {\n    return this._share.note;\n  }\n  /**\n   * Set the share note if any\n   */\n  set note(note) {\n    this._share.note = note;\n  }\n  /**\n   * Get the share label if any\n   * Should only exist on link shares\n   */\n  get label() {\n    return this._share.label ?? '';\n  }\n  /**\n   * Set the share label if any\n   * Should only be set on link shares\n   */\n  set label(label) {\n    this._share.label = label;\n  }\n  /**\n   * Have a mail been sent\n   */\n  get mailSend() {\n    return this._share.mail_send === true;\n  }\n  /**\n   * Hide the download button on public page\n   */\n  get hideDownload() {\n    return this._share.hide_download === true || this.attributes.find?.(_ref => {\n      let {\n        scope,\n        key,\n        value\n      } = _ref;\n      return scope === 'permissions' && key === 'download' && !value;\n    }) !== undefined;\n  }\n  /**\n   * Hide the download button on public page\n   */\n  set hideDownload(state) {\n    // disabling hide-download also enables the download permission\n    // needed for regression in Nextcloud 31.0.0 until (incl.) 31.0.3\n    if (!state) {\n      const attribute = this.attributes.find(_ref2 => {\n        let {\n          key,\n          scope\n        } = _ref2;\n        return key === 'download' && scope === 'permissions';\n      });\n      if (attribute) {\n        attribute.value = true;\n      }\n    }\n    this._share.hide_download = state === true;\n  }\n  /**\n   * Password protection of the share\n   */\n  get password() {\n    return this._share.password;\n  }\n  /**\n   * Password protection of the share\n   */\n  set password(password) {\n    this._share.password = password;\n  }\n  /**\n   * Password expiration time\n   * @return {string} date with YYYY-MM-DD format\n   */\n  get passwordExpirationTime() {\n    return this._share.password_expiration_time;\n  }\n  /**\n   * Password expiration time\n   * @param {string} passwordExpirationTime date with YYYY-MM-DD format\n   */\n  set passwordExpirationTime(passwordExpirationTime) {\n    this._share.password_expiration_time = passwordExpirationTime;\n  }\n  /**\n   * Password protection by Talk of the share\n   */\n  get sendPasswordByTalk() {\n    return this._share.send_password_by_talk;\n  }\n  /**\n   * Password protection by Talk of the share\n   *\n   * @param {boolean} sendPasswordByTalk whether to send the password by Talk or not\n   */\n  set sendPasswordByTalk(sendPasswordByTalk) {\n    this._share.send_password_by_talk = sendPasswordByTalk;\n  }\n  // SHARED ITEM DATA ---------------------------------------------\n  /**\n   * Get the shared item absolute full path\n   */\n  get path() {\n    return this._share.path;\n  }\n  /**\n   * Return the item type: file or folder\n   * @return {string} 'folder' | 'file'\n   */\n  get itemType() {\n    return this._share.item_type;\n  }\n  /**\n   * Get the shared item mimetype\n   */\n  get mimetype() {\n    return this._share.mimetype;\n  }\n  /**\n   * Get the shared item id\n   */\n  get fileSource() {\n    return this._share.file_source;\n  }\n  /**\n   * Get the target path on the receiving end\n   * e.g the file /xxx/aaa will be shared in\n   * the receiving root as /aaa, the fileTarget is /aaa\n   */\n  get fileTarget() {\n    return this._share.file_target;\n  }\n  /**\n   * Get the parent folder id if any\n   */\n  get fileParent() {\n    return this._share.file_parent;\n  }\n  // PERMISSIONS Shortcuts\n  /**\n   * Does this share have READ permissions\n   */\n  get hasReadPermission() {\n    return !!(this.permissions & window.OC.PERMISSION_READ);\n  }\n  /**\n   * Does this share have CREATE permissions\n   */\n  get hasCreatePermission() {\n    return !!(this.permissions & window.OC.PERMISSION_CREATE);\n  }\n  /**\n   * Does this share have DELETE permissions\n   */\n  get hasDeletePermission() {\n    return !!(this.permissions & window.OC.PERMISSION_DELETE);\n  }\n  /**\n   * Does this share have UPDATE permissions\n   */\n  get hasUpdatePermission() {\n    return !!(this.permissions & window.OC.PERMISSION_UPDATE);\n  }\n  /**\n   * Does this share have SHARE permissions\n   */\n  get hasSharePermission() {\n    return !!(this.permissions & window.OC.PERMISSION_SHARE);\n  }\n  /**\n   * Does this share have download permissions\n   */\n  get hasDownloadPermission() {\n    const hasDisabledDownload = attribute => {\n      return attribute.scope === 'permissions' && attribute.key === 'download' && attribute.value === false;\n    };\n    return this.attributes.some(hasDisabledDownload);\n  }\n  /**\n   * Is this mail share a file request ?\n   */\n  get isFileRequest() {\n    return isFileRequest(JSON.stringify(this.attributes));\n  }\n  set hasDownloadPermission(enabled) {\n    this.setAttribute('permissions', 'download', !!enabled);\n  }\n  setAttribute(scope, key, value) {\n    const attrUpdate = {\n      scope,\n      key,\n      value\n    };\n    // try and replace existing\n    for (const i in this._share.attributes) {\n      const attr = this._share.attributes[i];\n      if (attr.scope === attrUpdate.scope && attr.key === attrUpdate.key) {\n        this._share.attributes.splice(i, 1, attrUpdate);\n        return;\n      }\n    }\n    this._share.attributes.push(attrUpdate);\n  }\n  // PERMISSIONS Shortcuts for the CURRENT USER\n  // ! the permissions above are the share settings,\n  // ! meaning the permissions for the recipient\n  /**\n   * Can the current user EDIT this share ?\n   */\n  get canEdit() {\n    return this._share.can_edit === true;\n  }\n  /**\n   * Can the current user DELETE this share ?\n   */\n  get canDelete() {\n    return this._share.can_delete === true;\n  }\n  /**\n   * Top level accessible shared folder fileid for the current user\n   */\n  get viaFileid() {\n    return this._share.via_fileid;\n  }\n  /**\n   * Top level accessible shared folder path for the current user\n   */\n  get viaPath() {\n    return this._share.via_path;\n  }\n  // TODO: SORT THOSE PROPERTIES\n  get parent() {\n    return this._share.parent;\n  }\n  get storageId() {\n    return this._share.storage_id;\n  }\n  get storage() {\n    return this._share.storage;\n  }\n  get itemSource() {\n    return this._share.item_source;\n  }\n  get status() {\n    return this._share.status;\n  }\n  /**\n   * Is the share from a trusted server\n   */\n  get isTrustedServer() {\n    return !!this._share.is_trusted_server;\n  }\n}","/**\n * SPDX-FileCopyrightText: 2020 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport axios from '@nextcloud/axios';\nimport Config from \"../services/ConfigService.ts\";\nimport { showError, showSuccess } from '@nextcloud/dialogs';\nimport { translate as t } from '@nextcloud/l10n';\nconst config = new Config();\n// note: some chars removed on purpose to make them human friendly when read out\nconst passwordSet = 'abcdefgijkmnopqrstwxyzABCDEFGHJKLMNPQRSTWXYZ23456789';\n/**\n * Generate a valid policy password or request a valid password if password_policy is enabled\n *\n * @param {boolean} verbose If enabled the the status is shown to the user via toast\n */\nexport default async function () {\n  let verbose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  // password policy is enabled, let's request a pass\n  if (config.passwordPolicy.api && config.passwordPolicy.api.generate) {\n    try {\n      const request = await axios.get(config.passwordPolicy.api.generate);\n      if (request.data.ocs.data.password) {\n        if (verbose) {\n          showSuccess(t('files_sharing', 'Password created successfully'));\n        }\n        return request.data.ocs.data.password;\n      }\n    } catch (error) {\n      console.info('Error generating password from password_policy', error);\n      if (verbose) {\n        showError(t('files_sharing', 'Error generating password from password policy'));\n      }\n    }\n  }\n  const array = new Uint8Array(10);\n  const ratio = passwordSet.length / 255;\n  getRandomValues(array);\n  let password = '';\n  for (let i = 0; i < array.length; i++) {\n    password += passwordSet.charAt(array[i] * ratio);\n  }\n  return password;\n}\n/**\n * Fills the given array with cryptographically secure random values.\n * If the crypto API is not available, it falls back to less secure Math.random().\n * Crypto API is available in modern browsers on secure contexts (HTTPS).\n *\n * @param {Uint8Array} array - The array to fill with random values.\n */\nfunction getRandomValues(array) {\n  if (self?.crypto?.getRandomValues) {\n    self.crypto.getRandomValues(array);\n    return;\n  }\n  let len = array.length;\n  while (len--) {\n    array[len] = Math.floor(Math.random() * 256);\n  }\n}"],"names":[],"sourceRoot":""}