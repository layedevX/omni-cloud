{"version":3,"file":"files_sharing-init-public.js?v=d7aaaf9419b97ac6c097","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvFA;;;;;AEAA;AACA;AACA;AACA;AACA","sources":["webpack:///nextcloud/apps/files/src/logger.ts","webpack:///nextcloud/apps/files/src/services/Files.ts","webpack:///nextcloud/apps/files/src/services/RouterService.ts","webpack:///nextcloud/apps/files/src/services/Search.ts","webpack:///nextcloud/apps/files/src/services/WebDavSearch.ts","webpack:///nextcloud/apps/files/src/services/WebdavClient.ts","webpack:///nextcloud/apps/files/src/store/active.ts","webpack:///nextcloud/apps/files/src/store/files.ts","webpack:///nextcloud/apps/files/src/store/index.ts","webpack:///nextcloud/apps/files/src/store/paths.ts","webpack:///nextcloud/apps/files/src/store/search.ts","webpack:///nextcloud/apps/files/src/utils/filesViews.ts","webpack:///nextcloud/apps/files/src/views/files.ts","webpack:///nextcloud/apps/files/src/views/search.ts","webpack:///nextcloud/apps/files_sharing/src/files_views/publicFileDrop.ts","webpack:///nextcloud/apps/files_sharing/src/files_views/publicFileShare.ts","webpack:///nextcloud/apps/files_sharing/src/files_views/publicShare.ts","webpack:///nextcloud/apps/files_sharing/src/init-public.ts","webpack:///nextcloud/apps/files_sharing/src/router/index.ts","webpack:///nextcloud/apps/files_sharing/src/services/logger.ts","webpack:///nextcloud/webpack/bootstrap","webpack:///nextcloud/webpack/runtime/chunk loaded","webpack:///nextcloud/webpack/runtime/compat get default export","webpack:///nextcloud/webpack/runtime/define property getters","webpack:///nextcloud/webpack/runtime/ensure chunk","webpack:///nextcloud/webpack/runtime/get javascript chunk filename","webpack:///nextcloud/webpack/runtime/global","webpack:///nextcloud/webpack/runtime/hasOwnProperty shorthand","webpack:///nextcloud/webpack/runtime/load script","webpack:///nextcloud/webpack/runtime/make namespace object","webpack:///nextcloud/webpack/runtime/node module decorator","webpack:///nextcloud/webpack/runtime/publicPath","webpack:///nextcloud/webpack/runtime/jsonp chunk loading","webpack:///nextcloud/webpack/runtime/nonce","webpack:///nextcloud/webpack/before-startup","webpack:///nextcloud/webpack/startup","webpack:///nextcloud/webpack/after-startup"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { getLoggerBuilder } from '@nextcloud/logger';\nexport default getLoggerBuilder().setApp('files').detectUser().build();","import { defaultRootPath, getDefaultPropfind, resultToNode as davResultToNode } from '@nextcloud/files/dav';\nimport { CancelablePromise } from 'cancelable-promise';\nimport { join } from 'path';\nimport { client } from \"./WebdavClient.ts\";\nimport { searchNodes } from \"./WebDavSearch.ts\";\nimport { getPinia } from \"../store/index.ts\";\nimport { useFilesStore } from \"../store/files.ts\";\nimport { useSearchStore } from \"../store/search.ts\";\nimport logger from \"../logger.ts\";\n/**\n * Slim wrapper over `@nextcloud/files` `davResultToNode` to allow using the function with `Array.map`\n * @param stat The result returned by the webdav library\n */\nexport const resultToNode = stat => davResultToNode(stat);\n/**\n * Get contents implementation for the files view.\n * This also allows to fetch local search results when the user is currently filtering.\n *\n * @param path - The path to query\n */\nexport function getContents() {\n  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n  const controller = new AbortController();\n  const searchStore = useSearchStore(getPinia());\n  if (searchStore.query.length >= 3) {\n    return new CancelablePromise((resolve, reject, cancel) => {\n      cancel(() => controller.abort());\n      getLocalSearch(path, searchStore.query, controller.signal).then(resolve).catch(reject);\n    });\n  } else {\n    return defaultGetContents(path);\n  }\n}\n/**\n * Generic `getContents` implementation for the users files.\n *\n * @param path - The path to get the contents\n */\nexport function defaultGetContents(path) {\n  path = join(defaultRootPath, path);\n  const controller = new AbortController();\n  const propfindPayload = getDefaultPropfind();\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    onCancel(() => controller.abort());\n    try {\n      const contentsResponse = await client.getDirectoryContents(path, {\n        details: true,\n        data: propfindPayload,\n        includeSelf: true,\n        signal: controller.signal\n      });\n      const root = contentsResponse.data[0];\n      const contents = contentsResponse.data.slice(1);\n      if (root.filename !== path && `${root.filename}/` !== path) {\n        logger.debug(`Exepected \"${path}\" but got filename \"${root.filename}\" instead.`);\n        throw new Error('Root node does not match requested path');\n      }\n      resolve({\n        folder: resultToNode(root),\n        contents: contents.map(result => {\n          try {\n            return resultToNode(result);\n          } catch (error) {\n            logger.error(`Invalid node detected '${result.basename}'`, {\n              error\n            });\n            return null;\n          }\n        }).filter(Boolean)\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n/**\n * Get the local search results for the current folder.\n *\n * @param path - The path\n * @param query - The current search query\n * @param signal - The aboort signal\n */\nasync function getLocalSearch(path, query, signal) {\n  const filesStore = useFilesStore(getPinia());\n  let folder = filesStore.getDirectoryByPath('files', path);\n  if (!folder) {\n    const rootPath = join(defaultRootPath, path);\n    const stat = await client.stat(rootPath, {\n      details: true\n    });\n    folder = resultToNode(stat.data);\n  }\n  const contents = await searchNodes(query, {\n    dir: path,\n    signal\n  });\n  return {\n    folder,\n    contents\n  };\n}","function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nexport default class RouterService {\n  constructor(router) {\n    // typescript compiles this to `#router` to make it private even in JS,\n    // but in TS it needs to be called without the visibility specifier\n    _defineProperty(this, \"router\", void 0);\n    this.router = router;\n  }\n  get name() {\n    return this.router.currentRoute.name;\n  }\n  get query() {\n    return this.router.currentRoute.query || {};\n  }\n  get params() {\n    return this.router.currentRoute.params || {};\n  }\n  /**\n   * This is a protected getter only for internal use\n   * @private\n   */\n  get _router() {\n    return this.router;\n  }\n  /**\n   * Trigger a route change on the files app\n   *\n   * @param path the url path, eg: '/trashbin?dir=/Deleted'\n   * @param replace replace the current history\n   * @see https://router.vuejs.org/guide/essentials/navigation.html#navigate-to-a-different-location\n   */\n  goTo(path) {\n    let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.router.push({\n      path,\n      replace\n    });\n  }\n  /**\n   * Trigger a route change on the files App\n   *\n   * @param name the route name\n   * @param params the route parameters\n   * @param query the url query parameters\n   * @param replace replace the current history\n   * @see https://router.vuejs.org/guide/essentials/navigation.html#navigate-to-a-different-location\n   */\n  goToRoute(name, params, query, replace) {\n    return this.router.push({\n      name,\n      query,\n      params,\n      replace\n    });\n  }\n}","/*!\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { getCurrentUser } from '@nextcloud/auth';\nimport { Folder, Permission } from '@nextcloud/files';\nimport { defaultRemoteURL } from '@nextcloud/files/dav';\nimport { CancelablePromise } from 'cancelable-promise';\nimport { searchNodes } from \"./WebDavSearch.ts\";\nimport logger from \"../logger.ts\";\nimport { useSearchStore } from \"../store/search.ts\";\nimport { getPinia } from \"../store/index.ts\";\n/**\n * Get the contents for a search view\n */\nexport function getContents() {\n  const controller = new AbortController();\n  const searchStore = useSearchStore(getPinia());\n  return new CancelablePromise(async (resolve, reject, cancel) => {\n    cancel(() => controller.abort());\n    try {\n      const contents = await searchNodes(searchStore.query, {\n        signal: controller.signal\n      });\n      resolve({\n        contents,\n        folder: new Folder({\n          id: 0,\n          source: `${defaultRemoteURL}#search`,\n          owner: getCurrentUser().uid,\n          permissions: Permission.READ\n        })\n      });\n    } catch (error) {\n      logger.error('Failed to fetch search results', {\n        error\n      });\n      reject(error);\n    }\n  });\n}","/*!\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { getCurrentUser } from '@nextcloud/auth';\nimport { defaultRootPath, getDavNameSpaces, getDavProperties, resultToNode } from '@nextcloud/files/dav';\nimport { getBaseUrl } from '@nextcloud/router';\nimport { client } from \"./WebdavClient.ts\";\nimport logger from \"../logger.ts\";\n/**\n * Search for nodes matching the given query.\n *\n * @param query - Search query\n * @param options - Options\n * @param options.dir - The base directory to scope the search to\n * @param options.signal - Abort signal for the request\n */\nexport async function searchNodes(query, _ref) {\n  let {\n    dir,\n    signal\n  } = _ref;\n  const user = getCurrentUser();\n  if (!user) {\n    // the search plugin only works for user roots\n    return [];\n  }\n  query = query.trim();\n  if (query.length < 3) {\n    // the search plugin only works with queries of at least 3 characters\n    return [];\n  }\n  if (dir && !dir.startsWith('/')) {\n    dir = `/${dir}`;\n  }\n  logger.debug('Searching for nodes', {\n    query,\n    dir\n  });\n  const {\n    data\n  } = await client.search('/', {\n    details: true,\n    signal,\n    data: `\n<d:searchrequest ${getDavNameSpaces()}>\n\t <d:basicsearch>\n\t\t <d:select>\n\t\t\t <d:prop>\n\t\t\t ${getDavProperties()}\n\t\t\t </d:prop>\n\t\t </d:select>\n\t\t <d:from>\n\t\t\t <d:scope>\n\t\t\t\t <d:href>/files/${user.uid}${dir || ''}</d:href>\n\t\t\t\t <d:depth>infinity</d:depth>\n\t\t\t </d:scope>\n\t\t </d:from>\n\t\t <d:where>\n\t\t\t <d:like>\n\t\t\t\t <d:prop>\n\t\t\t\t\t <d:displayname/>\n\t\t\t\t </d:prop>\n\t\t\t\t <d:literal>%${query.replace('%', '')}%</d:literal>\n\t\t\t </d:like>\n\t\t </d:where>\n\t\t <d:orderby/>\n\t</d:basicsearch>\n</d:searchrequest>`\n  });\n  // check if the request was aborted\n  if (signal?.aborted) {\n    return [];\n  }\n  // otherwise return the result mapped to Nextcloud nodes\n  return data.results.map(result => resultToNode(result, defaultRootPath, getBaseUrl()));\n}","import { getClient, getDefaultPropfind, getRootPath, resultToNode } from '@nextcloud/files/dav';\nexport const client = getClient();\nexport const fetchNode = async path => {\n  const propfindPayload = getDefaultPropfind();\n  const result = await client.stat(`${getRootPath()}${path}`, {\n    details: true,\n    data: propfindPayload\n  });\n  return resultToNode(result.data);\n};","/**\n * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { subscribe } from '@nextcloud/event-bus';\nimport { getNavigation } from '@nextcloud/files';\nimport { defineStore } from 'pinia';\nimport { ref } from 'vue';\nimport logger from \"../logger.ts\";\nexport const useActiveStore = defineStore('active', () => {\n  /**\n   * The currently active action\n   */\n  const activeAction = ref();\n  /**\n   * The currently active folder\n   */\n  const activeFolder = ref();\n  /**\n   * The current active node within the folder\n   */\n  const activeNode = ref();\n  /**\n   * The current active view\n   */\n  const activeView = ref();\n  initialize();\n  /**\n   * Unset the active node if deleted\n   *\n   * @param node - The node thats deleted\n   * @private\n   */\n  function onDeletedNode(node) {\n    if (activeNode.value && activeNode.value.source === node.source) {\n      activeNode.value = undefined;\n    }\n  }\n  /**\n   * Callback to update the current active view\n   *\n   * @param view - The new active view\n   * @private\n   */\n  function onChangedView() {\n    let view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    logger.debug('Setting active view', {\n      view\n    });\n    activeView.value = view ?? undefined;\n    activeNode.value = undefined;\n  }\n  /**\n   * Initalize the store - connect all event listeners.\n   * @private\n   */\n  function initialize() {\n    const navigation = getNavigation();\n    // Make sure we only register the listeners once\n    subscribe('files:node:deleted', onDeletedNode);\n    onChangedView(navigation.active);\n    // Or you can react to changes of the current active view\n    navigation.addEventListener('updateActive', event => {\n      onChangedView(event.detail);\n    });\n  }\n  return {\n    activeAction,\n    activeFolder,\n    activeNode,\n    activeView\n  };\n});","/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { defineStore } from 'pinia';\nimport { subscribe } from '@nextcloud/event-bus';\nimport logger from \"../logger\";\nimport Vue from 'vue';\nimport { fetchNode } from \"../services/WebdavClient.ts\";\nimport { usePathsStore } from \"./paths.ts\";\nexport const useFilesStore = function () {\n  const store = defineStore('files', {\n    state: () => ({\n      files: {},\n      roots: {}\n    }),\n    getters: {\n      /**\n       * Get a file or folder by its source\n       * @param state\n       */\n      getNode: state => source => state.files[source],\n      /**\n       * Get a list of files or folders by their IDs\n       * Note: does not return undefined values\n       * @param state\n       */\n      getNodes: state => sources => sources.map(source => state.files[source]).filter(Boolean),\n      /**\n       * Get files or folders by their file ID\n       * Multiple nodes can have the same file ID but different sources\n       * (e.g. in a shared context)\n       * @param state\n       */\n      getNodesById: state => fileId => Object.values(state.files).filter(node => node.fileid === fileId),\n      /**\n       * Get the root folder of a service\n       * @param state\n       */\n      getRoot: state => service => state.roots[service]\n    },\n    actions: {\n      /**\n       * Get cached directory matching a given path\n       *\n       * @param service - The service (files view)\n       * @param path - The path relative within the service\n       * @return The folder if found\n       */\n      getDirectoryByPath(service, path) {\n        const pathsStore = usePathsStore();\n        let folder;\n        // Get the containing folder from path store\n        if (!path || path === '/') {\n          folder = this.getRoot(service);\n        } else {\n          const source = pathsStore.getPath(service, path);\n          if (source) {\n            folder = this.getNode(source);\n          }\n        }\n        return folder;\n      },\n      /**\n       * Get cached child nodes within a given path\n       *\n       * @param service - The service (files view)\n       * @param path - The path relative within the service\n       * @return Array of cached nodes within the path\n       */\n      getNodesByPath(service, path) {\n        const folder = this.getDirectoryByPath(service, path);\n        // If we found a cache entry and the cache entry was already loaded (has children) then use it\n        return (folder?._children ?? []).map(source => this.getNode(source)).filter(Boolean);\n      },\n      updateNodes(nodes) {\n        // Update the store all at once\n        const files = nodes.reduce((acc, node) => {\n          if (!node.fileid) {\n            logger.error('Trying to update/set a node without fileid', {\n              node\n            });\n            return acc;\n          }\n          acc[node.source] = node;\n          return acc;\n        }, {});\n        Vue.set(this, 'files', {\n          ...this.files,\n          ...files\n        });\n      },\n      deleteNodes(nodes) {\n        nodes.forEach(node => {\n          if (node.source) {\n            Vue.delete(this.files, node.source);\n          }\n        });\n      },\n      setRoot(_ref) {\n        let {\n          service,\n          root\n        } = _ref;\n        Vue.set(this.roots, service, root);\n      },\n      onDeletedNode(node) {\n        this.deleteNodes([node]);\n      },\n      onCreatedNode(node) {\n        this.updateNodes([node]);\n      },\n      onMovedNode(_ref2) {\n        let {\n          node,\n          oldSource\n        } = _ref2;\n        if (!node.fileid) {\n          logger.error('Trying to update/set a node without fileid', {\n            node\n          });\n          return;\n        }\n        // Update the path of the node\n        Vue.delete(this.files, oldSource);\n        this.updateNodes([node]);\n      },\n      async onUpdatedNode(node) {\n        if (!node.fileid) {\n          logger.error('Trying to update/set a node without fileid', {\n            node\n          });\n          return;\n        }\n        // If we have multiple nodes with the same file ID, we need to update all of them\n        const nodes = this.getNodesById(node.fileid);\n        if (nodes.length > 1) {\n          await Promise.all(nodes.map(node => fetchNode(node.path))).then(this.updateNodes);\n          logger.debug(nodes.length + ' nodes updated in store', {\n            fileid: node.fileid\n          });\n          return;\n        }\n        // If we have only one node with the file ID, we can update it directly\n        if (nodes.length === 1 && node.source === nodes[0].source) {\n          this.updateNodes([node]);\n          return;\n        }\n        // Otherwise, it means we receive an event for a node that is not in the store\n        fetchNode(node.path).then(n => this.updateNodes([n]));\n      },\n      // Handlers for legacy sidebar (no real nodes support)\n      onAddFavorite(node) {\n        const ourNode = this.getNode(node.source);\n        if (ourNode) {\n          Vue.set(ourNode.attributes, 'favorite', 1);\n        }\n      },\n      onRemoveFavorite(node) {\n        const ourNode = this.getNode(node.source);\n        if (ourNode) {\n          Vue.set(ourNode.attributes, 'favorite', 0);\n        }\n      }\n    }\n  });\n  const fileStore = store(...arguments);\n  // Make sure we only register the listeners once\n  if (!fileStore._initialized) {\n    subscribe('files:node:created', fileStore.onCreatedNode);\n    subscribe('files:node:deleted', fileStore.onDeletedNode);\n    subscribe('files:node:updated', fileStore.onUpdatedNode);\n    subscribe('files:node:moved', fileStore.onMovedNode);\n    // legacy sidebar\n    subscribe('files:favorites:added', fileStore.onAddFavorite);\n    subscribe('files:favorites:removed', fileStore.onRemoveFavorite);\n    fileStore._initialized = true;\n  }\n  return fileStore;\n};","/**\n * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { createPinia } from 'pinia';\nexport const getPinia = () => {\n  if (window._nc_files_pinia) {\n    return window._nc_files_pinia;\n  }\n  window._nc_files_pinia = createPinia();\n  return window._nc_files_pinia;\n};","import { defineStore } from 'pinia';\nimport { dirname } from '@nextcloud/paths';\nimport { File, FileType, getNavigation } from '@nextcloud/files';\nimport { subscribe } from '@nextcloud/event-bus';\nimport Vue from 'vue';\nimport logger from \"../logger\";\nimport { useFilesStore } from \"./files\";\nexport const usePathsStore = function () {\n  const files = useFilesStore(...arguments);\n  const store = defineStore('paths', {\n    state: () => ({\n      paths: {}\n    }),\n    getters: {\n      getPath: state => {\n        return (service, path) => {\n          if (!state.paths[service]) {\n            return undefined;\n          }\n          return state.paths[service][path];\n        };\n      }\n    },\n    actions: {\n      addPath(payload) {\n        // If it doesn't exists, init the service state\n        if (!this.paths[payload.service]) {\n          Vue.set(this.paths, payload.service, {});\n        }\n        // Now we can set the provided path\n        Vue.set(this.paths[payload.service], payload.path, payload.source);\n      },\n      deletePath(service, path) {\n        // skip if service does not exist\n        if (!this.paths[service]) {\n          return;\n        }\n        Vue.delete(this.paths[service], path);\n      },\n      onCreatedNode(node) {\n        const service = getNavigation()?.active?.id || 'files';\n        if (!node.fileid) {\n          logger.error('Node has no fileid', {\n            node\n          });\n          return;\n        }\n        // Only add path if it's a folder\n        if (node.type === FileType.Folder) {\n          this.addPath({\n            service,\n            path: node.path,\n            source: node.source\n          });\n        }\n        // Update parent folder children if exists\n        // If the folder is the root, get it and update it\n        this.addNodeToParentChildren(node);\n      },\n      onDeletedNode(node) {\n        const service = getNavigation()?.active?.id || 'files';\n        if (node.type === FileType.Folder) {\n          // Delete the path\n          this.deletePath(service, node.path);\n        }\n        this.deleteNodeFromParentChildren(node);\n      },\n      onMovedNode(_ref) {\n        let {\n          node,\n          oldSource\n        } = _ref;\n        const service = getNavigation()?.active?.id || 'files';\n        // Update the path of the node\n        if (node.type === FileType.Folder) {\n          // Delete the old path if it exists\n          const oldPath = Object.entries(this.paths[service]).find(_ref2 => {\n            let [, source] = _ref2;\n            return source === oldSource;\n          });\n          if (oldPath?.[0]) {\n            this.deletePath(service, oldPath[0]);\n          }\n          // Add the new path\n          this.addPath({\n            service,\n            path: node.path,\n            source: node.source\n          });\n        }\n        // Dummy simple clone of the renamed node from a previous state\n        const oldNode = new File({\n          source: oldSource,\n          owner: node.owner,\n          mime: node.mime\n        });\n        this.deleteNodeFromParentChildren(oldNode);\n        this.addNodeToParentChildren(node);\n      },\n      deleteNodeFromParentChildren(node) {\n        const service = getNavigation()?.active?.id || 'files';\n        // Update children of a root folder\n        const parentSource = dirname(node.source);\n        const folder = node.dirname === '/' ? files.getRoot(service) : files.getNode(parentSource);\n        if (folder) {\n          // ensure sources are unique\n          const children = new Set(folder._children ?? []);\n          children.delete(node.source);\n          Vue.set(folder, '_children', [...children.values()]);\n          logger.debug('Children updated', {\n            parent: folder,\n            node,\n            children: folder._children\n          });\n          return;\n        }\n        logger.debug('Parent path does not exists, skipping children update', {\n          node\n        });\n      },\n      addNodeToParentChildren(node) {\n        const service = getNavigation()?.active?.id || 'files';\n        // Update children of a root folder\n        const parentSource = dirname(node.source);\n        const folder = node.dirname === '/' ? files.getRoot(service) : files.getNode(parentSource);\n        if (folder) {\n          // ensure sources are unique\n          const children = new Set(folder._children ?? []);\n          children.add(node.source);\n          Vue.set(folder, '_children', [...children.values()]);\n          logger.debug('Children updated', {\n            parent: folder,\n            node,\n            children: folder._children\n          });\n          return;\n        }\n        logger.debug('Parent path does not exists, skipping children update', {\n          node\n        });\n      }\n    }\n  });\n  const pathsStore = store(...arguments);\n  // Make sure we only register the listeners once\n  if (!pathsStore._initialized) {\n    subscribe('files:node:created', pathsStore.onCreatedNode);\n    subscribe('files:node:deleted', pathsStore.onDeletedNode);\n    subscribe('files:node:moved', pathsStore.onMovedNode);\n    pathsStore._initialized = true;\n  }\n  return pathsStore;\n};","/*!\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { emit, subscribe } from '@nextcloud/event-bus';\nimport debounce from 'debounce';\nimport { defineStore } from 'pinia';\nimport { ref, watch } from 'vue';\nimport { VIEW_ID } from \"../views/search.ts\";\nimport logger from \"../logger.ts\";\nexport const useSearchStore = defineStore('search', () => {\n  /**\n   * The current search query\n   */\n  const query = ref('');\n  /**\n   * Scope of the search.\n   * Scopes:\n   * - filter: only filter current file list\n   * - globally: search everywhere\n   */\n  const scope = ref('filter');\n  // reset the base if query is cleared\n  watch(scope, updateSearch);\n  watch(query, (old, current) => {\n    // skip if only whitespaces changed\n    if (old.trim() === current.trim()) {\n      return;\n    }\n    updateSearch();\n  });\n  // initialize the search store\n  initialize();\n  /**\n   * Debounced update of the current route\n   * @private\n   */\n  const updateRouter = debounce(isSearch => {\n    const router = window.OCP.Files.Router;\n    router.goToRoute(undefined, {\n      view: VIEW_ID\n    }, {\n      query: query.value\n    }, isSearch);\n  });\n  /**\n   * Handle updating the filter if needed.\n   * Also update the search view by updating the current route if needed.\n   *\n   * @private\n   */\n  function updateSearch() {\n    // emit the search event to update the filter\n    emit('files:search:updated', {\n      query: query.value,\n      scope: scope.value\n    });\n    const router = window.OCP.Files.Router;\n    // if we are on the search view and the query was unset or scope was set to 'filter' we need to move back to the files view\n    if (router.params.view === VIEW_ID && (query.value === '' || scope.value === 'filter')) {\n      scope.value = 'filter';\n      return router.goToRoute(undefined, {\n        view: 'files'\n      }, {\n        ...router.query,\n        query: undefined\n      });\n    }\n    // for the filter scope we do not need to adjust the current route anymore\n    // also if the query is empty we do not need to do anything\n    if (scope.value === 'filter' || !query.value) {\n      return;\n    }\n    const isSearch = router.params.view === VIEW_ID;\n    logger.debug('Update route for updated search query', {\n      query: query.value,\n      isSearch\n    });\n    updateRouter(isSearch);\n  }\n  /**\n   * Event handler that resets the store if the file list view was changed.\n   *\n   * @param view - The new view that is active\n   * @private\n   */\n  function onViewChanged(view) {\n    if (view.id !== VIEW_ID) {\n      query.value = '';\n      scope.value = 'filter';\n    }\n  }\n  /**\n   * Initialize the store from the router if needed\n   */\n  function initialize() {\n    subscribe('files:navigation:changed', onViewChanged);\n    const router = window.OCP.Files.Router;\n    // if we initially load the search view (e.g. hard page refresh)\n    // then we need to initialize the store from the router\n    if (router.params.view === VIEW_ID) {\n      query.value = [router.query.query].flat()[0] ?? '';\n      if (query.value) {\n        scope.value = 'globally';\n        logger.debug('Directly navigated to search view', {\n          query: query.value\n        });\n      } else {\n        // we do not have any query so we need to move to the files list\n        logger.info('Directly navigated to search view without any query, redirect to files view.');\n        router.goToRoute(undefined, {\n          ...router.params,\n          view: 'files'\n        }, {\n          ...router.query,\n          query: undefined\n        }, true);\n      }\n    }\n  }\n  return {\n    query,\n    scope\n  };\n});","/**\n * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { loadState } from '@nextcloud/initial-state';\n/**\n * Check whether the personal files view can be shown\n */\nexport function hasPersonalFilesView() {\n  const storageStats = loadState('files', 'storageStats', {\n    quota: -1\n  });\n  // Don't show this view if the user has no storage quota\n  return storageStats.quota !== 0;\n}\n/**\n * Get the default files view\n */\nexport function defaultView() {\n  const {\n    default_view: defaultView\n  } = loadState('files', 'config', {\n    default_view: 'files'\n  });\n  // the default view - only use the personal one if it is enabled\n  if (defaultView !== 'personal' || hasPersonalFilesView()) {\n    return defaultView;\n  }\n  return 'files';\n}","/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { emit, subscribe } from '@nextcloud/event-bus';\nimport { View, getNavigation } from '@nextcloud/files';\nimport { t } from '@nextcloud/l10n';\nimport { getContents } from \"../services/Files.ts\";\nimport { useActiveStore } from \"../store/active.ts\";\nimport { defaultView } from \"../utils/filesViews.ts\";\nimport FolderSvg from '@mdi/svg/svg/folder-outline.svg?raw';\nexport const VIEW_ID = 'files';\n/**\n * Register the files view to the navigation\n */\nexport function registerFilesView() {\n  // we cache the query to allow more performant search (see below in event listener)\n  let oldQuery = '';\n  const Navigation = getNavigation();\n  Navigation.register(new View({\n    id: VIEW_ID,\n    name: t('files', 'All files'),\n    caption: t('files', 'List of your files and folders.'),\n    icon: FolderSvg,\n    // if this is the default view we set it at the top of the list - otherwise below it\n    order: defaultView() === VIEW_ID ? 0 : 5,\n    getContents\n  }));\n  // when the search is updated\n  // and we are in the files view\n  // and there is already a folder fetched\n  // then we \"update\" it to trigger a new `getContents` call to search for the query while the filelist is filtered\n  subscribe('files:search:updated', _ref => {\n    let {\n      scope,\n      query\n    } = _ref;\n    if (scope === 'globally') {\n      return;\n    }\n    if (Navigation.active?.id !== VIEW_ID) {\n      return;\n    }\n    // If neither the old query nor the new query is longer than the search minimum\n    // then we do not need to trigger a new PROPFIND / SEARCH\n    // so we skip unneccessary requests here\n    if (oldQuery.length < 3 && query.length < 3) {\n      return;\n    }\n    const store = useActiveStore();\n    if (!store.activeFolder) {\n      return;\n    }\n    oldQuery = query;\n    emit('files:node:updated', store.activeFolder);\n  });\n}","/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { View, getNavigation } from '@nextcloud/files';\nimport { t } from '@nextcloud/l10n';\nimport { getContents } from \"../services/Search.ts\";\nimport { VIEW_ID as FILES_VIEW_ID } from \"./files.ts\";\nimport MagnifySvg from '@mdi/svg/svg/magnify.svg?raw';\nimport Vue from 'vue';\nexport const VIEW_ID = 'search';\n/**\n * Register the search-in-files view\n */\nexport function registerSearchView() {\n  let instance;\n  let view;\n  const Navigation = getNavigation();\n  Navigation.register(new View({\n    id: VIEW_ID,\n    name: t('files', 'Search'),\n    caption: t('files', 'Search results within your files.'),\n    async emptyView(el) {\n      if (!view) {\n        view = (await import(\"./SearchEmptyView.vue\")).default;\n      } else {\n        instance.$destroy();\n      }\n      instance = new Vue(view);\n      instance.$mount(el);\n    },\n    icon: MagnifySvg,\n    order: 10,\n    parent: FILES_VIEW_ID,\n    // it should be shown expanded\n    expanded: true,\n    // this view is hidden by default and only shown when active\n    hidden: true,\n    getContents\n  }));\n}","import { Folder, Permission, View, getNavigation } from '@nextcloud/files';\nimport { defaultRemoteURL, defaultRootPath } from '@nextcloud/files/dav';\nimport { loadState } from '@nextcloud/initial-state';\nimport { translate as t } from '@nextcloud/l10n';\nimport svgCloudUpload from '@mdi/svg/svg/cloud-upload.svg?raw';\nimport Vue from 'vue';\nexport default () => {\n  const foldername = loadState('files_sharing', 'filename');\n  let FilesViewFileDropEmptyContent;\n  let fileDropEmptyContentInstance;\n  const view = new View({\n    id: 'public-file-drop',\n    name: t('files_sharing', 'File drop'),\n    caption: t('files_sharing', 'Upload files to {foldername}', {\n      foldername\n    }),\n    icon: svgCloudUpload,\n    order: 1,\n    emptyView: async div => {\n      if (FilesViewFileDropEmptyContent === undefined) {\n        const {\n          default: component\n        } = await import(\"../views/FilesViewFileDropEmptyContent.vue\");\n        FilesViewFileDropEmptyContent = Vue.extend(component);\n      }\n      if (fileDropEmptyContentInstance) {\n        fileDropEmptyContentInstance.$destroy();\n      }\n      fileDropEmptyContentInstance = new FilesViewFileDropEmptyContent({\n        propsData: {\n          foldername\n        }\n      });\n      fileDropEmptyContentInstance.$mount(div);\n    },\n    getContents: async () => {\n      return {\n        contents: [],\n        // Fake a writeonly folder as root\n        folder: new Folder({\n          id: 0,\n          source: `${defaultRemoteURL}${defaultRootPath}`,\n          root: defaultRootPath,\n          owner: null,\n          permissions: Permission.CREATE\n        })\n      };\n    }\n  });\n  const Navigation = getNavigation();\n  Navigation.register(view);\n};","import { Folder, Permission, View, davGetDefaultPropfind, davRemoteURL, davResultToNode, davRootPath, getNavigation } from '@nextcloud/files';\nimport { translate as t } from '@nextcloud/l10n';\nimport { CancelablePromise } from 'cancelable-promise';\nimport LinkSvg from '@mdi/svg/svg/link.svg?raw';\nimport { client } from \"../../../files/src/services/WebdavClient\";\nimport logger from \"../services/logger\";\nexport default () => {\n  const view = new View({\n    id: 'public-file-share',\n    name: t('files_sharing', 'Public file share'),\n    caption: t('files_sharing', 'Publicly shared file.'),\n    emptyTitle: t('files_sharing', 'No file'),\n    emptyCaption: t('files_sharing', 'The file shared with you will show up here'),\n    icon: LinkSvg,\n    order: 1,\n    getContents: () => {\n      return new CancelablePromise(async (resolve, reject, onCancel) => {\n        const abort = new AbortController();\n        onCancel(() => abort.abort());\n        try {\n          const node = await client.stat(davRootPath, {\n            data: davGetDefaultPropfind(),\n            details: true,\n            signal: abort.signal\n          });\n          resolve({\n            // We only have one file as the content\n            contents: [davResultToNode(node.data)],\n            // Fake a readonly folder as root\n            folder: new Folder({\n              id: 0,\n              source: `${davRemoteURL}${davRootPath}`,\n              root: davRootPath,\n              owner: null,\n              permissions: Permission.READ,\n              attributes: {\n                // Ensure the share note is set on the root\n                note: node.data.props?.note\n              }\n            })\n          });\n        } catch (e) {\n          logger.error(e);\n          reject(e);\n        }\n      });\n    }\n  });\n  const Navigation = getNavigation();\n  Navigation.register(view);\n};","/**\n * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { translate as t } from '@nextcloud/l10n';\nimport { View, getNavigation } from '@nextcloud/files';\nimport LinkSvg from '@mdi/svg/svg/link.svg?raw';\nimport { getContents } from \"../../../files/src/services/Files\";\nexport default () => {\n  const view = new View({\n    id: 'public-share',\n    name: t('files_sharing', 'Public share'),\n    caption: t('files_sharing', 'Publicly shared files.'),\n    emptyTitle: t('files_sharing', 'No files'),\n    emptyCaption: t('files_sharing', 'Files and folders shared with you will show up here'),\n    icon: LinkSvg,\n    order: 1,\n    getContents\n  });\n  const Navigation = getNavigation();\n  Navigation.register(view);\n};","import { emit, subscribe, unsubscribe } from '@nextcloud/event-bus';\nimport { getNavigation } from '@nextcloud/files';\nimport { loadState } from '@nextcloud/initial-state';\nimport registerFileDropView from \"./files_views/publicFileDrop.ts\";\nimport registerPublicShareView from \"./files_views/publicShare.ts\";\nimport registerPublicFileShareView from \"./files_views/publicFileShare.ts\";\nimport RouterService from \"../../files/src/services/RouterService.ts\";\nimport router from \"./router/index.ts\";\nimport logger from \"./services/logger.ts\";\nregisterFileDropView();\nregisterPublicShareView();\nregisterPublicFileShareView();\n// Get the current view from state and set it active\nconst view = loadState('files_sharing', 'view');\nconst navigation = getNavigation();\nnavigation.setActive(navigation.views.find(_ref => {\n  let {\n    id\n  } = _ref;\n  return id === view;\n}) ?? null);\n// Force our own router\nwindow.OCP.Files = window.OCP.Files ?? {};\nwindow.OCP.Files.Router = new RouterService(router);\n// If this is a single file share, so set the fileid as active in the URL\nconst fileId = loadState('files_sharing', 'fileId', null);\nconst token = loadState('files_sharing', 'sharingToken');\nif (fileId !== null) {\n  window.OCP.Files.Router.goToRoute('filelist', {\n    ...window.OCP.Files.Router.params,\n    token,\n    fileid: String(fileId)\n  }, {\n    ...window.OCP.Files.Router.query,\n    openfile: 'true'\n  });\n}\n// When the file list is loaded we need to apply the \"userconfig\" setup on the share\nsubscribe('files:list:updated', loadShareConfig);\n/**\n * Event handler to load the view config for the current share.\n * This is done on the `files:list:updated` event to ensure the list and especially the config store was correctly initialized.\n *\n * @param context The event context\n * @param context.folder The current folder\n */\nfunction loadShareConfig(_ref2) {\n  let {\n    folder\n  } = _ref2;\n  // Only setup config once\n  unsubscribe('files:list:updated', loadShareConfig);\n  // Share attributes (the same) are set on all folders of a share\n  if (folder.attributes['share-attributes']) {\n    const shareAttributes = JSON.parse(folder.attributes['share-attributes'] || '[]');\n    const gridViewAttribute = shareAttributes.find(_ref3 => {\n      let {\n        scope,\n        key\n      } = _ref3;\n      return scope === 'config' && key === 'grid_view';\n    });\n    if (gridViewAttribute !== undefined) {\n      logger.debug('Loading share attributes', {\n        gridViewAttribute\n      });\n      emit('files:config:updated', {\n        key: 'grid_view',\n        value: gridViewAttribute.value === true\n      });\n    }\n  }\n}","import { loadState } from '@nextcloud/initial-state';\nimport { generateUrl } from '@nextcloud/router';\nimport queryString from 'query-string';\nimport Router, { isNavigationFailure, NavigationFailureType } from 'vue-router';\nimport Vue from 'vue';\nimport logger from \"../services/logger\";\nconst view = loadState('files_sharing', 'view');\nconst sharingToken = loadState('files_sharing', 'sharingToken');\nVue.use(Router);\n// Prevent router from throwing errors when we're already on the page we're trying to go to\nconst originalPush = Router.prototype.push;\nRouter.prototype.push = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length > 1) {\n    return originalPush.call(this, ...args);\n  }\n  return originalPush.call(this, args[0]).catch(ignoreDuplicateNavigation);\n};\nconst originalReplace = Router.prototype.replace;\nRouter.prototype.replace = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  if (args.length > 1) {\n    return originalReplace.call(this, ...args);\n  }\n  return originalReplace.call(this, args[0]).catch(ignoreDuplicateNavigation);\n};\n/**\n * Ignore duplicated-navigation error but forward real exceptions\n * @param error The thrown error\n */\nfunction ignoreDuplicateNavigation(error) {\n  if (isNavigationFailure(error, NavigationFailureType.duplicated)) {\n    logger.debug('Ignoring duplicated navigation from vue-router', {\n      error\n    });\n  } else {\n    throw error;\n  }\n}\nconst router = new Router({\n  mode: 'history',\n  // if index.php is in the url AND we got this far, then it's working:\n  // let's keep using index.php in the url\n  base: generateUrl('/s'),\n  linkActiveClass: 'active',\n  routes: [{\n    path: '/',\n    // Pretending we're using the default view\n    redirect: {\n      name: 'filelist',\n      params: {\n        view,\n        token: sharingToken\n      }\n    }\n  }, {\n    path: '/:token',\n    name: 'filelist',\n    props: true\n  }],\n  // Custom stringifyQuery to prevent encoding of slashes in the url\n  stringifyQuery(query) {\n    const result = queryString.stringify(query).replace(/%2F/gmi, '/');\n    return result ? '?' + result : '';\n  }\n});\nexport default router;","/**\n * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { getLoggerBuilder } from '@nextcloud/logger';\nexport default getLoggerBuilder().setApp('files_sharing').detectUser().build();","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \"-\" + chunkId + \".js?v=\" + {\"apps_files_src_views_SearchEmptyView_vue\":\"f4a1d1b5018f4999b20a\",\"apps_files_sharing_src_views_FilesViewFileDropEmptyContent_vue\":\"6a1507033cb434cf8579\",\"node_modules_nextcloud_dialogs_dist_chunks_index-BC-7VPxC_mjs\":\"2fcef36253529e5f48bc\",\"node_modules_nextcloud_dialogs_dist_chunks_PublicAuthPrompt-ecDAsnUN_mjs\":\"d90f915546feffda97c2\",\"node_modules_nextcloud_upload_dist_chunks_ConflictPicker-DUp0Tl_A_mjs\":\"2b7e5e7d66bfa4c34e07\",\"node_modules_nextcloud_upload_dist_chunks_InvalidFilenameDialog-B_BCSatD_mjs\":\"59d127696747fece8ee8\",\"node_modules_nextcloud_dialogs_dist_chunks_FilePicker-CsU6FfAP_mjs\":\"0d588b9b111349c79c3c\",\"data_image_svg_xml_3c_21--_20-_20SPDX-FileCopyrightText_202020_20Google_20Inc_20-_20SPDX-Lice-cc29b1\":\"9fa10a9863e5b78deec8\"}[chunkId] + \"\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"nextcloud:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"files_sharing-init-public\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunknextcloud\"] = self[\"webpackChunknextcloud\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"core-common\"], () => (__webpack_require__(\"./apps/files_sharing/src/init-public.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}